name: Build in-code documentation
on:
  push:
    branches:
      - main
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          repository: giellalt/giellalt.github.io

      - name: Install realpath
        run: |
          which realpath

      - name: Setup Node.js for Slidev
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install Slidev and dependencies
        run: |
          npm install -g @slidev/cli
          npm install -g @slidev/theme-default
          npm install -g playwright-chromium

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.1'
          bundler-cache: true

      - name: Build Slidev presentations
        env:
          CI: true
          NODE_ENV: production
        run: |
          # Find all markdown files that should have slidev presentations
          find . -name "*.md" -not -path "./_*" -not -path "./node_modules/*" | while read mdfile; do
            basename=$(basename "$mdfile" .md)
            dirname=$(dirname "$mdfile")
            slidev_dir="${dirname}/${basename}-slidev"
            
            # Check if there are any links to this slidev/dist directory in the site
            if grep -r "${basename}-slidev/dist/" . --include="*.md" --include="*.html" > /dev/null 2>&1; then
              echo "Building Slidev presentation for $mdfile -> $slidev_dir (triggered by ${basename}-slidev/dist/ link)"
              mkdir -p "$slidev_dir"
              
              # Copy and adapt the markdown for Slidev
              # First check if the source file already has frontmatter
              if head -n 1 "$mdfile" | grep -q "^---$"; then
                echo "Source file already has frontmatter, using as-is"
                echo "=== Processing file with existing frontmatter ==="
                # Extract frontmatter (from first --- to second ---)
                awk '/^---$/{count++} count==1{print} count==2{print; exit}' "$mdfile" > "$slidev_dir/slides.md"
                # Extract content after second ---
                awk '/^---$/{count++; if(count==2) skip=1; next} skip && NF' "$mdfile" > "$slidev_dir/step1.md"
              else
                echo "Adding default frontmatter to source file"
                echo "---" > "$slidev_dir/slides.md"
                echo "theme: seriph" >> "$slidev_dir/slides.md"
                echo "background: https://unsplash.com/photos/clear-blue-running-water-at-daytime-OR_3rbIv5yI" >> "$slidev_dir/slides.md"
                echo "class: text-center" >> "$slidev_dir/slides.md"
                echo "highlighter: shiki" >> "$slidev_dir/slides.md"
                echo "lineNumbers: false" >> "$slidev_dir/slides.md"
                echo "info: |" >> "$slidev_dir/slides.md"
                echo "  Presentation generated from $(basename $mdfile)" >> "$slidev_dir/slides.md"
                echo "drawings:" >> "$slidev_dir/slides.md"
                echo "  persist: false" >> "$slidev_dir/slides.md"
                echo "---" >> "$slidev_dir/slides.md"
                echo "" >> "$slidev_dir/slides.md"
                echo "=== Processing file without frontmatter ==="
                cat "$mdfile" > "$slidev_dir/step1.md"
              fi
              
              # Smart image handling - find and copy only referenced images
              echo "=== Finding referenced images in markdown ==="
              
              # Create images directory in slidev project
              mkdir -p "$slidev_dir/images"
              
              # Extract all image references from the markdown file
              # This handles: ![alt](path), ![alt](path "title"), and YAML image: path
              mdfile_dir=$(dirname "$mdfile")
              
              # Find all image references and process them
              grep -E '!\[.*\]\(.*\)|image:\s*[^[:space:]]+' "$mdfile" | while IFS= read -r line; do
                # Extract image path from markdown syntax ![](path) or YAML image: path
                if echo "$line" | grep -q '!\[.*\]'; then
                  # Markdown image syntax: ![alt](path)
                  img_path=$(echo "$line" | sed -n 's/.*!\[.*\](\([^)]*\)).*/\1/p' | sed 's/[[:space:]]*".*$//')
                elif echo "$line" | grep -q 'image:'; then
                  # YAML image property: image: path
                  img_path=$(echo "$line" | sed -n 's/.*image:[[:space:]]*\([^[:space:]]*\).*/\1/p')
                else
                  continue
                fi
                
                if [ -n "$img_path" ]; then
                  echo "Found image reference: $img_path"
                  
                  # Determine source path based on reference type
                  if [[ "$img_path" == ../* ]]; then
                    # Relative to parent: ../images/file.png
                    src_path="${img_path#../}"
                  elif [[ "$img_path" == ./* ]]; then
                    # Relative to current: ./images/file.png
                    src_path="$mdfile_dir/${img_path#./}"
                  elif [[ "$img_path" == /* ]]; then
                    # Absolute from root: /images/file.png
                    src_path="${img_path#/}"
                  else
                    # Relative path: images/file.png
                    src_path="$mdfile_dir/$img_path"
                  fi
                  
                  # Copy the image if it exists, create placeholder if not
                  if [ -f "$src_path" ]; then
                    # Get just the filename for destination
                    img_filename=$(basename "$img_path")
                    cp "$src_path" "$slidev_dir/images/$img_filename"
                    echo "Copied: $src_path â†’ $slidev_dir/images/$img_filename"
                  else
                    echo "WARNING: Image not found: $src_path (referenced as: $img_path)"
                    # Create a placeholder text file that can be referenced
                    img_filename=$(basename "$img_path")
                    echo "ðŸ–¼ï¸ IMAGE MISSING: $img_path" > "$slidev_dir/images/missing-${img_filename%.png}.txt"
                    echo "Created placeholder for missing image: $img_filename"
                  fi
                fi
              done
              
              # Convert markdown content for Slidev format and fix image paths
              echo "=== Processing markdown content ==="
              echo "Before conversion:"
              tail -n +2 "$mdfile" | head -10
              
              # Test the sed commands manually first
              echo "=== Testing sed commands ==="
              echo "Test 1 - ../images/file.png:"
              echo "![ErrorModelWithBoth](../images/ErrorModelWithBoth.png)" | sed 's|!\[\([^]]*\)\](\([^/]*/\)*\([^/)]*\.\(png\|jpg\|jpeg\|gif\|svg\|webp\))\)|![\1](./images/\3)|g'
              echo "Test 2 - /images/file.png:"
              echo "![ErrorModelWithBoth](/images/ErrorModelWithBoth.png)" | sed 's|!\[\([^]]*\)\](\([^/]*/\)*\([^/)]*\.\(png\|jpg\|jpeg\|gif\|svg\|webp\))\)|![\1](./images/\3)|g'
              echo "Test 3 - ./images/file.png:"
              echo "![Spellingdir](./images/spellingdir.png)" | sed 's|!\[\([^]]*\)\](\([^/]*/\)*\([^/)]*\.\(png\|jpg\|jpeg\|gif\|svg\|webp\))\)|![\1](./images/\3)|g'
              echo "Test 4 - YAML image property:"
              echo "image: ../images/ErrorModelWithBoth.png" | sed 's|image: \([^/]*/\)*\([^/]*\.\(png\|jpg\|jpeg\|gif\|svg\|webp\)\)|image: ./images/\2|g'
              echo "Test 5 - Complex path:"
              echo "![Test](./subdir/images/test.png)" | sed 's|!\[\([^]]*\)\](\([^/]*/\)*\([^/)]*\.\(png\|jpg\|jpeg\|gif\|svg\|webp\))\)|![\1](./images/\3)|g'
              
              # Process content step by step using temp files
              echo "=== Step 1 - Original content ==="
              echo "Content of step1.md:"
              cat "$slidev_dir/step1.md"
              echo "--- End of step1.md ---"
              grep "images/" "$slidev_dir/step1.md" || echo "No images found"
              
              sed 's/^# /---\n\n# /' "$slidev_dir/step1.md" > "$slidev_dir/step2.md"
              echo "=== Step 2 - After header conversion ==="
              grep "images/" "$slidev_dir/step2.md" || echo "No images found"
              
              # Normalize all image paths and handle missing images
              # First, normalize existing images to ./images/filename
              sed 's|!\[\([^]]*\)\](\([^/]*/\)*\([^/)]*\.\(png\|jpg\|jpeg\|gif\|svg\|webp\))\)|![\1](./images/\3)|g; s|image: \([^/]*/\)*\([^/]*\.\(png\|jpg\|jpeg\|gif\|svg\|webp\)\)|image: ./images/\2|g' "$slidev_dir/step2.md" > "$slidev_dir/step3_temp.md"
              
              # Then, replace references to missing images with error messages
              while IFS= read -r line; do
                if echo "$line" | grep -q '!\[.*\](./images/.*\)'; then
                  # Extract image filename from markdown
                  img_file=$(echo "$line" | sed -n 's/.*!\[.*\](\.\/images\/\([^)]*\)).*/\1/p')
                  if [ -n "$img_file" ] && [ ! -f "$slidev_dir/images/$img_file" ]; then
                    # Image is missing, replace with error message
                    alt_text=$(echo "$line" | sed -n 's/.*!\[\([^]]*\)\].*/\1/p')
                    echo "$line" | sed "s|!\[.*\](./images/.*)|**ðŸš« MISSING IMAGE: $img_file** *(was: $alt_text)*|g"
                  else
                    echo "$line"
                  fi
                elif echo "$line" | grep -q 'image: ./images/'; then
                  # Extract image filename from YAML
                  img_file=$(echo "$line" | sed -n 's/.*image: \.\/images\/\([^[:space:]]*\).*/\1/p')
                  if [ -n "$img_file" ] && [ ! -f "$slidev_dir/images/$img_file" ]; then
                    # Image is missing, comment out the line and add error
                    echo "# MISSING IMAGE: $img_file"
                    echo "# $line"
                  else
                    echo "$line"
                  fi
                else
                  echo "$line"
                fi
              done < "$slidev_dir/step3_temp.md" > "$slidev_dir/step3.md"
              
              # Clean up temp file
              rm -f "$slidev_dir/step3_temp.md"
              echo "=== Step 3 - After image path conversion ==="
              grep "images/" "$slidev_dir/step3.md" || echo "No images found"
              
              cat "$slidev_dir/step3.md" >> "$slidev_dir/slides.md"
              
              # Clean up temp files
              rm -f "$slidev_dir/step1.md" "$slidev_dir/step2.md" "$slidev_dir/step3.md"
              
              echo "=== Final slides.md content (image references) ==="
              grep -n "images/" "$slidev_dir/slides.md" || echo "No image references found"
              
              echo "=== Complete slides.md content ==="
              echo "--- START OF slides.md ---"
              cat "$slidev_dir/slides.md"
              echo "--- END OF slides.md ---"
              echo "slides.md file size: $(wc -l < "$slidev_dir/slides.md") lines"
              
              # Build the presentation  
              cd "$slidev_dir"
              echo "Building Slidev presentation with dynamic path"
              echo "Current directory: $(pwd)"
              echo "Dirname: $dirname, Basename: $basename"
              # Convert relative path to absolute path for Vite
              absolute_base="${dirname#./}/${basename}-slidev/dist/"
              if [[ "$absolute_base" == "/${basename}-slidev/dist/" ]]; then
                # If dirname was ".", use root path
                absolute_base="/${basename}-slidev/dist/"
              else
                # Add leading slash for absolute path
                absolute_base="/$absolute_base"
              fi
              echo "Building with base: $absolute_base"
              
              # Build and immediately check results
              if echo "yes" | slidev build slides.md --base "$absolute_base" --out dist; then
                echo "=== Slidev build completed successfully ==="
                echo "=== Checking generated files ==="
                ls -la dist/ || echo "No dist directory found"
                echo "=== Checking complete index.html content ==="
                if [ -f "dist/index.html" ]; then
                  cat dist/index.html
                else
                  echo "No index.html found in dist/"
                fi
              else
                echo "=== Slidev build FAILED ==="
                echo "Exit code: $?"
              fi
              
              # Ensure images are available in the built presentation
              if [ -d "images" ] && [ -d "dist" ]; then
                cp -r images dist/
                echo "Copied images to dist directory for runtime access"
              fi
              
              # Fix SPA routing for GitHub Pages
              echo "Fixing SPA routing for GitHub Pages"
              cp dist/index.html dist/404.html
              echo "Created 404.html from index.html for SPA routing"
              
              cd - > /dev/null
              
              # Remove slides.md to prevent Jekyll from processing it
              rm "$slidev_dir/slides.md"
              echo "Removed slides.md from $slidev_dir to prevent Jekyll conflicts"
            fi
          done

      - name: Build Jekyll site
        env:
          JEKYLL_GITHUB_TOKEN: ${{ secrets.GIELLALT_DOCS_GH_TOKEN }}
        run: |
          echo "=== Starting Jekyll build ==="
          bundle exec jekyll build --verbose
          echo "=== Jekyll build complete ==="
          echo "Checking what Jekyll generated in _site:"
          ls -la _site/ | grep -E "(slidev|presentation)" || echo "No Slidev directories found in _site"

      - name: Note about Slidev presentations
        run: |
          echo "=== Slidev presentations are handled by Jekyll as static files ==="
          echo "Jekyll automatically copies *-slidev/dist/ directories to _site/"
          echo "No additional copying needed - presentations will be available at:"
          echo "  https://giellalt.github.io/test-presentation-slidev/dist/"

      - name: deploy gh pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: _site
          enable_jekyll: false
